/* This exec uses COPYFILE to copy a list of Minidisks.  This list may
   have been made by MVMDISKS XEDIT, or by hand.
 +-----------------------------------------------------------------+
 | format:  | CLSTCMS   listfid  <( <RACFDEF> <RACFDEL> <RR|MR> >  |
 +-----------------------------------------------------------------+
 Options: RACFDEF   tells that RACF RDEFINEs and PERMITs will be given
          RACFDEL   is to undo the RACF defines after the copy
          RR or MR  can be used to LINK input disk in RR.  BUT, your COPY
                    becomes worthless if someone else changes the disk.
 
Sample input List:
==================
 EXEC XXX MAINTEST 174 MMAINT   MAINTEST 1174 MMAINT
 EXEC XXX MAINT    343 MULT     MAINT    1343 MULT
 EXEC XXX VMUTIL   191 MUTIL    VMUTIL   1191 MMAINT
 
  Description: first 2 words are ignored
               words 3-5 define input disk (userid, cuu, multpswd)
               words 6-8 define output disk (userid, cuu, multpswd)
  Records starting with an * are ignored, also, if you write a - sign
  in col 1, the copy is not attempted, you can use this to signal CLSTSMS
  it should not retry a copy that failed before.
Output list:
============
 This exec will read the input list and create a LOGfile in which it will
 write the state of each copy.  This same file can be used as input list
 when the copy has to be restarted.  Lines for successfull copies are
 preceded by an *, so they are not re-attempted. Sample
* EXEC XXX MAINTEST 174 MMAINT   MAINTEST 1174 MMAINT      OK 20 Jan 1992
* EXEC XXX MAINT    343 MULT     MAINT    1343 MULT        OK 20 Jan 1992
  EXEC XXX VMUTIL   191 MUTIL    VMUTIL   1191 MUTIL       +++Failed+++
 
Prereq:
 -if using RACF, you'll need RACF authority to link to the disks
  (e.g. you could define yourself as OPERATIONS)
 
  Written by: Kris Buelens IBM Belgium;  BUELENSC at IECVM 14 Jan 1992*/
parse upper source . . myname mytype . syn .
address command
parse upper arg copylist '(' options
 
parse value 0     0       0      'M'       userid(),
       with MaxRc RacfDef RacfDel LinkMode userid
 
do while Options<>''
   parse var options option options
   select
    when option='RACFDEF' then RacfDef=1
    when option='DEFRACF' then RacfDef=1
    when option='RACFDEL' then RacfDel=1
    when option='DELRACF' then RacfDel=1
    when option='RR'      then LinkMode='RR'
    when option='MR'      then LinkMode='MR'
    Otherwise
     call errexit 5,'Invalid parameter:' option
   end
end
 
if copylist='' then call errexit 5,'Fileid of list missing'
CopyList=subword(CopyList 'A',1,3)
'EXECIO * DISKR' copylist '(FINIS STEM LIST.'
if rc^=0 then call errexit rc,'+++++++++++> EXECIO DISKR failed'
 
loglist=word(copylist,1) 'LOG A'
'ESTATE' loglist
if rc^=0 then 'COPYFILE' copylist loglist '(RECFM F LRECL 200'
 
'CP SP CON START TO * CONT CLOSE'
'CP CLOSE CONS NAME' myname 'ERROR'
do i=1 to list.0
   parse var list.i c1 2 1 . . inu ina inpw outu outa outpw .
   if c1='*' then iterate i
   if c1='-' then iterate i /* no retry if error */
   if inu='*' then inu=userid
   if outu='*' then outu=userid
   if outa='=' then outa=ina
   if outu='=' then outu=inu
   if outpw='=' then outpw=inpw
   Say '===============' inu ina 'TO' outu outa '======================='
   If RacfDef then call RACFDEF inu ina outu outa
   parse value copyCMS() with copyrc error
   if copyrc=0 then str='*' left(list.i,60) 'OK' date() time()
   else do
      say '+++Failed+++' error
      str=left(list.i,60) '+++Failed+++ rc='copyrc error
      maxrc=max(maxrc,copyrc)
   end
   'EXECIO 1 DISKW' loglist i '(FINIS STRING' str
   if inacc     then 'RELEASE' my_infm
   if outacc    then 'RELEASE' my_outfm
   if inlinked  then call diag 8,'DET' my_ina
   if outlinked then call diag 8,'DET' my_outa
   If RacfDel then call RACFDEL inu ina outu outa
   if copyrc=0 then 'VMFCLEAR'
end
 
call errexit maxrc
 
Errexit:
 do i=2 to arg()
    Say arg(i)
 end i
 if arg(1)=0 then name='DONE'
             else name='FAIL'
 'CP CLOSE CONS NAME' myname name
 'CP SP CON STOP CLOSE NOCONT'
exit arg(1)
 
/*-----------------------------------------------------------------*/
COPYCMS: /*                                                        */
/*-----------------------------------------------------------------*/
 inlink=1   ;outlink=1   /* suppose we have to link to the disks */
 inlinked=0 ;outlinked=0 /* not yet linked */
 inacc=0    ;outacc=0
 'GETFMADR';Parse Upper Pull . my_infm my_ina .
 if inu=myself then do
    parse value diagrc(8,'Q V' ina) with rc . 17 type . . . stat .
    if rc=0 & stat type='R/W DASD' then parse value ina    0,
                                        with  my_ina inlink
 end
 if inlink then do
    parse value diagrc(8,'LINK' inu ina my_ina LinkMode inpw),
                with rc . 17 cpans
    if (rc>=101 & rc<=103) then do; rc=0;say cpans;end /* forced R/O*/
    if rc^=0 then return rc 'LINK-in ' cpans
    inlinked=1
 end
 'ACCESS' my_ina my_infm
 If rc=0 then inacc=1
 If rc= 28 then do
    inacc=0;nbf=0
    'DEVTYPE' my_ina '(STACK'
    if rc=0 then parse pull . . . . . lbl
            Else lbl=left(inu,6)
    Say 'Disk is empty, we''ll FORMAT' outu outa 'labeled' lbl
    rc=0
 end
 If rc<>0 then return rc 'Problem with ACCESS input disk.'
 If inacc then do
    'Q DISK' my_infm '(LIFO'
/*---output of:  Q DISK -------------------------------------------------
LABEL  VDEV M  STAT   CYL TYPE BLKSZ   FILES  BLKS USED-(%) BLKS LEFT
KRIS   191  A   R/W     3 3390 4096       47        310-57        230
RACF   140  H   R/O    20 3390            OS
--words:----W3--W4-----W5-W6---W7-------W8--------W9--------------W10-1*/
    parse pull lbl 7 . . . . . fmt nbf .;pull
    If right(fmt,2)='OS' then
       return 88 'Sorry, can''t COPYFILE an' fmt 'formatted disk.'
 end
 Say myname':      ' inu ina 'linked as:' my_ina
 
 'GETFMADR';Parse Upper Pull . my_outfm my_outa .
 if outu='*' | outu=myself then do
    parse value diagrc(8,'Q V' outa) with rc . 17 type . . . stat .
    if rc=0 & stat type='R/W DASD' then parse value outa    0,
                                        with  my_outa outlink
 end
 if outlink then do
    parse value diagrc(8,'LINK' outu outa my_outa 'M' outpw),
                with rc . 17 cpans
    if rc^=0 then return rc 'LINK-out' cpans
    outlinked=1
 end
 Say myname':      ' outu outa 'linked as:' my_outa
 
 /* Now we have both Mdisks, get some more info on devtype ect. */
 push lbl;push 'YES'
 'FORMAT' my_outa my_outfm
 If rc<>0 then return rc 'Problem with FORMAT output disk.'
 outacc=1
 if nbf=0 then return 0
 Say 'Copying 'nbf' files ......'
 'COPYFILE * *' my_infm '= = ' my_outfm '(OLDDATE'
 If rc<>0 then return rc 'COPYFILE * *' my_infm '= = ' my_outfm 'failed'
 return 0
 
RACFDEF:
 procedure expose userid
 parse arg u1 a1 u2 a2
 'CP SET MSG OFF'
 'SET CMSTYPE HT'
 'MAKEBUF'
 queue 'RDEFINE VMMDISK' u1'.'a1' OWNER('userid')'
 queue 'PERMIT' u1'.'a1' CLASS(VMMDISK) ID('userid') ACCESS(CONTROL)'
 queue 'RDEFINE VMMDISK' u2'.'a2' OWNER('userid')'
 queue 'PERMIT' u2'.'a2' CLASS(VMMDISK) ID('userid') ACCESS(CONTROL)'
 queue 'END'
 'RACF (BATCH'
 'DROPBUF'
 'CP SET MSG ON'
 'SET CMSTYPE RT'
return
 
RACFDEL:
 procedure expose userid
 parse arg u1 a1 u2 a2
 'CP SET MSG OFF'
 'SET CMSTYPE HT'
 'MAKEBUF'
 queue 'PERMIT' u1'.'a1' CLASS(VMMDISK) ID('userid') DELETE'
 queue 'RDELETE VMMDISK' u2'.'a2
 queue 'END'
 'RACF (BATCH'
 'DROPBUF'
 'CP SET MSG ON'
 'SET CMSTYPE RT'
return
