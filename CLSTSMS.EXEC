/* This can use DFSMS COPY to copy a list of Minidisks.  This list may
   have been made by MVMDISKS XEDIT, or by hand.
 +----------------------------------------------------------------------+
 | format:  | CLSTSMS   listfid  <( <RACFDEF> <RACFDEL> <CHECK> <RR|MR> |
 |          |                       <OPTimize 1|2|3|4> <PACE>           |
 |          |                       <NOREComp>
 +----------------------------------------------------------------------+
 Options: RACFDEF   tells that RACF RDEFINEs and PERMITs will be given
          RACFDEL   is to undo the RACF defines after the copy
          CHECK     to run a DFSMS CHECK after each copy
          RR or MR  can be used to LINK input disk in RR.  BUT, your COPY
                    becomes worthless if someone else changes the disk.
          OPTIMIZE  asks to use the DFSMS COPY OPTIMIZE option
          PACE      asks to use the DFSMS COPY PACE
          NORECOMP  to skip the FORMAT (RECOMP after DFSMS COPY
                    (use only if both mdisks have same nbr of CMS blocks)
 
Sample input List:
==================
 EXEC XXX MAINTEST 174 MMAINT   MAINTEST 1174 MMAINT
 EXEC XXX MAINT    343 MULT     MAINT    1343 MULT
 EXEC XXX VMUTIL   191 MUTIL    VMUTIL   1191 MMAINT
 
  Description: first 2 words are ignored
               words 3-5 define input disk (userid, cuu, multpswd)
               words 6-8 define output disk (userid, cuu, multpswd)
  Records starting with an * are ignored, also, if you write a - sign
  in col 1, the copy is not attempted, you can use this to signal CLSTSMS
  it should not retry a copy that failed before.
Output list:
============
 This exec will read the input list and create a LOGfile in which it will
 write the state of each copy.  This same file can be used as input list
 when the copy has to be restarted.  Lines for successfull copies are
 preceded by an *, so they are not re-attempted. Sample
* EXEC XXX MAINTEST 174 MMAINT   MAINTEST 1174 MMAINT      OK 20 Jan 1992
* EXEC XXX MAINT    343 MULT     MAINT    1343 MULT        OK 20 Jan 1992
  EXEC XXX VMUTIL   191 MUTIL    VMUTIL   1191 MUTIL       +++Failed+++
 
Prereq:
 -you'll need to LINK to the disk containing DFSMS (DGTOWNER 191)
 -if using RACF, you'll need RACF authority to link to the disks
  (e.g. you could define yourself as OPERATIONS)
 
22 Feb 1996: Added a few extra options (as OPTIMIZE)
  Written by: Kris Buelens IBM Belgium;  BUELENSC at IECVM 14 Jan 1992*/
parse upper source . . myname mytype . syn .
address command
parse upper arg copylist '(' options
 
parse value 1      0     0       0       0       'M'       userid(),
       with Recomp MaxRc RacfDef RacfDel DFSMSchk LinkMode userid . '' ,
            Optimize pace
do while Options<>''
   parse var options option options
   select
    when option='PACE'    then PACE='PACE'
    when abbrev('NORECOMP',option,5) then recomp=0
    when abbrev('OPTIMIZE',option,3) then do
         parse var options speed options
         if find('1 2 3 4',speed)=0 then
            call errexit 5,'Invalid parm for OPTIMIZE: "'speed'"'
         optimize='OPTIMIZE' speed
    end
    when option='CHECK'   then DFSMSchk=1
    when option='RACFDEF' then RacfDef=1
    when option='DEFRACF' then RacfDef=1
    when option='RACFDEL' then RacfDel=1
    when option='DELRACF' then RacfDel=1
    when option='RR'      then LinkMode='RR'
    when option='MR'      then LinkMode='MR'
    Otherwise
     call errexit 5,'Invalid parameter:' option
   end
end
 
'CMDCALL ESTATE DFSMS MODULE *'
if rc<>0 then call errexit rc,'We need DFSMS COPY to work.'
 
if copylist='' then call errexit 5,'Fileid of list missing'
CopyList=subword(CopyList 'A',1,3)
'EXECIO * DISKR' copylist '(FINIS STEM LIST.'
if rc^=0 then call errexit rc,'+++++++++++> EXECIO DISKR failed'
 
loglist=word(copylist,1) 'LOG A'
'ESTATE' loglist
if rc^=0 then 'COPYFILE' copylist loglist '(RECFM F LRECL 200'
 
Trace -1  /* no errormsg if PIPE not existing */
'PIPE COMMAND Q SEARCH',  /* Get High used fmodes */
   '|SPEC w3 1.1|LITERAL ABCDEFGHIJKLMNOPQRSTUVWXYZ|DEBLOCK 1',
   '|SORT D|UNIQUE SINGLES|VAR FreeModes'
If symbol('Freemodes')<>'VAR' Then WorkMode='Z'
                              else WorkMode=left(Freemodes,1)
 
'CP SP CON START TO * CONT CLOSE'
'CP CLOSE CONS NAME' myname 'ERROR'
do i=1 to list.0
   parse var list.i c1 2 1 . . inu ina inpw outu outa outpw .
   if c1='*' then iterate i
   if c1='-' then iterate i /* no retry if error */
   if inu='*' then inu=userid
   if outu='*' then outu=userid
   if outa='=' then outa=ina
   if outu='=' then outu=inu
   if outpw='=' then outpw=inpw
   Say '===============' inu ina 'TO' outu outa '======================='
   If RacfDef then call RACFDEF inu ina outu outa
   parse value copySMS() with copyrc error
   if copyrc=0 then str='*' left(list.i,60) 'OK' date() time()
   else do
      say '+++Failed+++' error
      str=left(list.i,60) '+++Failed+++ rc='copyrc error
      maxrc=max(maxrc,copyrc)
   end
   'EXECIO 1 DISKW' loglist i '(FINIS STRING' str
   if inlinked  then call diag 8,'DET' my_ina
   if outlinked then call diag 8,'DET' my_outa
   If RacfDel then call RACFDEL inu ina outu outa
   if copyrc=0 then 'VMFCLEAR'
end
 
call errexit maxrc
 
Errexit:
 do i=2 to arg()
    Say arg(i)
 end i
 if arg(1)=0 then name='DONE'
             else name='FAIL'
 'CP CLOSE CONS NAME' myname name
 'CP SP CON STOP CLOSE NOCONT'
exit arg(1)
 
/*-----------------------------------------------------------------*/
COPYSMS: /*                                                        */
/*-----------------------------------------------------------------*/
 inlink=1   ;outlink=1   /* suppose we have to link to the disks */
 inlinked=0 ;outlinked=0 /* not yet linked */
 
 'GETFMADR';Parse Upper Pull . . my_ina .
 if inu=myself then do
    parse value diagrc(8,'Q V' ina) with rc . 17 type . . . stat .
    if rc=0 & stat type='R/W DASD' then parse value ina    0,
                                        with  my_ina inlink
 end
 if inlink then do
    parse value diagrc(8,'LINK' inu ina my_ina LinkMode inpw),
                with rc . 17 cpans
    if (rc>=101 & rc<=103) then do; rc=0;say cpans;end /* forced R/O*/
    if rc^=0 then return rc 'LINK-in ' cpans
    inlinked=1
 end
 Say myname':      ' inu ina 'linked as:' my_ina
 
 'GETFMADR';Parse Upper Pull . . my_outa .
 if outu='*' | outu=myself then do
    parse value diagrc(8,'Q V' outa) with rc . 17 type . . . stat .
    if rc=0 & stat type='R/W DASD' then parse value outa    0,
                                        with  my_outa outlink
 end
 if outlink then do
    parse value diagrc(8,'LINK' outu outa my_outa 'M' outpw),
                with rc . 17 cpans
    if rc^=0 then return rc 'LINK-out' cpans
    outlinked=1
 end
 Say myname':      ' outu outa 'linked as:' my_outa
 
 /* Now we have both Mdisks, get some more info on devtype ect. */
 'ACCESS' my_ina WorkMode
 If rc= 28 then
    return rc 'Disk empty and Read-Only; DFSMS COPY impossible.'
 if rc<>0 then return rc 'ACCESS  Error input accessing disk'
 
 'DFSMS COPY' WorkMode my_outa '(' optimize pace ;smsrc=rc
 'RELEASE' WorkMode
 if smsrc^=0 then return smsrc 'DFSMScpy DFSMS COPY failed.'
 
 If DFSMSchk then do
    'DFSMS CHECK' my_outa
    if rc^=0 then return rc 'DFSMSchk DFSMS CHECK failed.'
 end
 If recomp then do
    'ACCESS' my_outa workmode
    'FORMAT' my_outa workmode '(RECOMP';src=rc
    'RELEASE' WorkMode
    if src^=0 then return src 'FORMAT (RECOMP failed.'
 end
 return 0
 
RACFDEF:
 procedure expose userid
 parse arg u1 a1 u2 a2
 'CP SET MSG OFF'
 'SET CMSTYPE HT'
 'MAKEBUF'
 queue 'RDEFINE VMMDISK' u1'.'a1' OWNER('userid')'
 queue 'PERMIT' u1'.'a1' CLASS(VMMDISK) ID('userid') ACCESS(CONTROL)'
 queue 'RDEFINE VMMDISK' u2'.'a2' OWNER('userid')'
 queue 'PERMIT' u2'.'a2' CLASS(VMMDISK) ID('userid') ACCESS(CONTROL)'
 queue 'END'
 'RACF (BATCH'
 'DROPBUF'
 'CP SET MSG ON'
 'SET CMSTYPE RT'
return
 
RACFDEL:
 procedure expose userid
 parse arg u1 a1 u2 a2
 'CP SET MSG OFF'
 'SET CMSTYPE HT'
 'MAKEBUF'
 queue 'PERMIT' u1'.'a1' CLASS(VMMDISK) ID('userid') DELETE'
 queue 'RDELETE VMMDISK' u2'.'a2
 queue 'END'
 'RACF (BATCH'
 'DROPBUF'
 'CP SET MSG ON'
 'SET CMSTYPE RT'
return
