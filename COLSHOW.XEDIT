/*==============================================================*/
/*    Program Name - XEDIT Column Editing/VM                    */
/*    Licensed Material - Program Property of IBM               */
/*                                                              */
/*    Copyright              (c) IBM Corp 1992                  */
/*--------------------------------------------------------------*/
 
Pull name                        /* Isolate text to be edited   */
If name = '' Then Do
 "COMMAND SET MSGMODE ON"
  Say 'No name has been stacked, Exiting COLSHOW XEDIT'
  Queue 'QQUIT'
  Exit
End
'COMMAND SET MSGMODE OFF'
'COMMAND DELETE /'name'/'
If rc ^= 0 Then Do
  Say name 'Not found in COLDEMO TEXT, File may be missing or down level.'
 "QQUIT"
  Exit
End
'COMMAND DELETE 1'
'COMMAND FIND XCOL'
If rc = 0 Then 'COMMAND DELETE *'
'COMMAND SET MSGMODE ON'
'COMMAND SET CURLINE ON 4'
'COMMAND TOP'
 
Interpret 'CALL' name
 
"QQUIT"
Exit
 
/* alignment tool!  ....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8 */
 
XCOLTFLO:
Queue 'COLCMD       ????????????????W??z??????????????????????????????????z??????W??????????'
/* XCOLTFLO.1 Wordflow, justifying left and right, the paragraphs.  The*/
/* XCOLTFLO.1 optional Zones within the W's indicate that the text     */
/* XCOLTFLO.1 found between the W's is to be Squeezed between the Z's. */
Queue 'COLCMD'
Queue 'COLCMD       ????j????????????jr?????????????????????????????????????????????????????'
/* XCOLTFLO.3 Right justify the text between the J's */
/* XCOLTFLO.3 If only one J was entered, then the    */
/* XCOLTFLO.3 default first J would be column 1.     */
Queue 'COLCMD'
Queue 'COLCMD       ????j????????????jc?????????????????????????????????????????????????????'
/* XCOLTFLO.5 Center the text between the J's.  If only*/
/* XCOLTFLO.5 one J was entered, then the default would*/
/* XCOLTFLO.5 be to center the entire line at the J.   */
Queue 'COLCMD'
Queue 'COLCMD       ????j????????????jl?????????????????????????????????????????????????????'
/* XCOLTFLO.7 Left justify the text between the J's  */
/* XCOLTFLO.7 If only one J was entered, then the    */
/* XCOLTFLO.7 default second J would be end of line. */
Queue 'COLCMD'
Queue 'COLCMD       ??????????????>??????????????????????????????????????????>??????????????'
/* XCOLTFLO.9 Flow the text, right justifying the paragraphs.*/
Queue 'COLCMD'
Queue 'COLCMD       ??????????????<?????????????????????????????????????????????<???????????'
/* XCOLTFLO.11 Flow the text, left justifying the paragraphs.*/
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????????????????????????????????????jl????????'
/* XCOLTFLO.13 Left justify the text between the J's  */
/* XCOLTFLO.13 Since only one J was entered, then the */
/* XCOLTFLO.13 default second J is the end of line.   */
Queue 'ECOL'
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLSUBT:
Queue 'COLCMD       ????????????????????????????+++++++++++++++++(s'
/* XCOLSUBT.1 Create Subtotals.  The totals are*/
/* XCOLSUBT.1 aligned with the rightmost +.    */
Queue 'COLCMD'
Queue 'COLCMD       ?eeeeeeeeeeeeeeeeeeeeeeee??????????????????????'
/* XCOLSUBT.3 Emulate or copy forward the*/
/* XCOLSUBT.3 data in columns 2 - 25.    */
Queue 'COLCMD'
Queue 'COLPCM d     ??????????????????????????????????????       ??'
/* XCOLSUBT.5 Search for blanks in columns 39 - 45.*/
/* XCOLSUBT.5 When found issue the XEDIT prefix    */
/* XCOLSUBT.5 command D to Delete the line.        */
Queue 'COLCMD'
/* XCOLSUBT.6 Now let us calculate the percentage that*/
/* XCOLSUBT.6 each line represents of the total.     */
Queue 'COLCMD       ????????????????????????????????????++++++++++++++++++'
/* XCOLSUBT.7 Find the total offsetting*/
/* XCOLSUBT.7 the answer into column 54.*/
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????????????????eeeeeee\'
/* XCOLSUBT.9 Emulate or copy forward the data in columns 48 - 54     */
/* XCOLSUBT.9 BACKWARD.  The \ operator causes the command to proceed */
/* XCOLSUBT.9 from the bottom up rather than the normal top to bottom.*/
Queue 'COLCMD'
Queue 'COLMAT       ????????????????????????????????????yyyyyyyyy??yyyyyyy??==.==={y.1 / y.2 * 100}'
/* XCOLSUBT.11 Mark the columns that contain our data with Y's.  Place */
/* XCOLSUBT.11 equal signs where you desire to have the answer placed. */
/* XCOLSUBT.11 You may also enter a decimal point to indicate where you*/
/* XCOLSUBT.11 would like to have the decimal point placed in the      */
/* XCOLSUBT.11 answer.  Simultaneously enter your mathematical (REXX)  */
/* XCOLSUBT.11 expression in the XEDIT command line.  The name of the  */
/* XCOLSUBT.11 first column is y.1, the second y.2 etc.  Press ENTER.  */
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????????????????ddddddd?'
/* XCOLSUBT.13 Delete the unused total column.*/
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????????????????????????????i%'
/* XCOLSUBT.15 Insert a percent sign.*/
Queue 'ECOL'
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLSEPS:
Queue 'COLCMD       !!!'
/* XCOLSEPS.1 Use the exclamation command to insert the blank lines. */
/* XCOLSEPS.1 Whenever the data within the column changes a line will*/
/* XCOLSEPS.1 be inserted.  You may enter "!!!(text" to insert "text"*/
/* XCOLSEPS.1 rather than inserting blank lines or "!!!(" and          */
/* XCOLSEPS.1 simultaneously enter the desired text in the XEDIT       */
/* XCOLSEPS.1 command line.  This allows easier text alignment.        */
Queue 'COLCMD'
/* XCOLSEPS.2 That was Easy!  If you wanted three lines*/
/* XCOLSEPS.2 added you could have entered: !!!(3      */
Queue 'ECOL'
'MACRO COL * ? @  NOEXIT NOPROF STEP'
Return
 
XCOLHEAA:
Queue 'COLPCM X2    1???'
/* XCOLHEAA.1 Search for 1 in column 1.  When */
/* XCOLHEAA.1 found apply the XEDIT prefix    */
/* XCOLHEAA.1 command X2 to eXclude two lines.*/
Queue 'COLCMD'
Queue 'COLCMD       ?s1s?????????????????????????g2ggggg'
/* XCOLHEAA.3 Sort the displayed lines.  Note that when sorting within */
/* XCOLHEAA.3 COL that excluded lines are honored unlike the sort      */
/* XCOLHEAA.3 command when used outside of COL.  You may also mix      */
/* XCOLHEAA.3 ascending S and descending G commands.  The imbedded     */
/* XCOLHEAA.3 numbers indicate the sort priority.  If no numbers were  */
/* XCOLHEAA.3 entered, the priority would be left to right.            */
Queue 'COLCMD'
Queue 'COLXED ALL'
/* XCOLHEAA.5 Show ALL lines.*/
Queue 'COLCMD'
Queue 'COLXCM       1{-1 I  .cp}'
/* XCOLHEAA.7 Search for 1 in column 1.  When */
/* XCOLHEAA.7 found apply the XEDIT command   */
/* XCOLHEAA.7 -1 I  .cp to backup one line and*/
/* XCOLHEAA.7 insert the text "blank" .cp     */
Queue 'COLCMD'
Queue 'COLCMD       d???'
/* XCOLHEAA.9 Delete column one.*/
Queue 'ECOL'
'MACRO COL * ? @  NOEXIT NOPROF STEP'
Return
 
XCOLHEAD:
Queue 'COLPCM X2    1????????????????????????????????????????????????????????????????????????????'
/* XCOLHEAD.1 Search for 1 in column 1.  When */
/* XCOLHEAD.1 found apply the XEDIT prefix    */
/* XCOLHEAD.1 command X2 to eXclude two lines.*/
Queue 'COLCMD'
Queue 'COLCMD       ?s1s?????????????????????????g2ggggg'
/* XCOLHEAD.3 Sort the displayed lines.  Note that when sorting within */
/* XCOLHEAD.3 COL that excluded lines are honored unlike the sort      */
/* XCOLHEAD.3 command when used outside of COL.  You may also mix      */
/* XCOLHEAD.3 ascending S and descending G commands.  The imbedded     */
/* XCOLHEAD.3 numbers indicate the sort priority.  If no numbers were  */
/* XCOLHEAD.3 entered, the priority would be left to right.            */
Queue 'COLCMD'
Queue 'COLXED ALL'
/* XCOLHEAD.5 Show ALL lines.*/
Queue 'COLCMD'
Queue 'COLXED MASK I  .cp'
/* XCOLHEAD.7 Set XEDIT's mask for Input and */
/* XCOLHEAD.7 Add to the text "blank" .cp    */
Queue 'COLCMD'
Queue 'COLPCM i@-1  1????????????????????????????????????????????????????????????????????????????'
/* XCOLHEAD.9 Search for 1 in column 1.  When found apply the    */
/* XCOLHEAD.9 XEDIT prefix command I offsetting (@) by -1 line.  */
/* XCOLHEAD.9 The input will occur one line above the text match.*/
Queue 'COLCMD'
Queue 'COLXED MASK I'
/* XCOLHEAD.11 Reset XEDIT's mask for Input and Add.*/
Queue 'COLCMD       d????????????????????????????????????????????????????????????????????????????'
/* XCOLHEAD.12 Delete column one.*/
Queue 'ECOL'
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLSORT:
'COMMAND SET CURLINE ON M'
'Command Locate :8'
Queue 'COLCMD       ?????????????z s2 s1sssssss z'
/* XCOLSORT.1 Sort the text between the Zones.  This text is to be */
/* XCOLSORT.1 sorted based first on the last name and secondly on  */
/* XCOLSORT.1 the initials.  Text outside of the zones is not altered.*/
Queue 'ECOL'
'MACRO COL 4 NOEXIT NOPROF STEP'
Return
 
XCOLPIPE:
 Queue 'COLCMD YYYYYYYYYYYYYYYYYYYYYYYYYY'
/* XCOLPIPE.1 Mark the columnw to be operated upon with  */
/* XCOLPIPE.1 Y's.  A Y* would have indicated that the   */
/* XCOLPIPE.1 operation would go to the end of the line. */
 Queue 'COLXED COLPIPE spec w 3.1 1 w 1.1 nextword | xlate , 40'
/* XCOLPIPE.2 Enter the COL pipeline command COLPIPE with the desired */
/* XCOLPIPE.2 pipeline stages.  This one takes the 3rd word and       */
/* XCOLPIPE.2 places into column 1.  The 1st word is then placed into */
/* XCOLPIPE.2 the next word.  Commas are then translated to blanks.   */
 Queue 'ECOL'
/* XCOLPIPE.3 Text outside of the marked */
/* XCOLPIPE.3 columns are not altered.   */
'MACRO COL * NOEXIT STEP'
Return
 
XCOLUMN:
Queue 'COLCMD       ???????????????????u????????????????????????????????????xxxxxxx??????????????'
/* XCOLUMN.1 Xfer (Transfer) columns Upon another.  The Xfer command  */
/* XCOLUMN.1 will leave a blank column under the X's The Upon target  */
/* XCOLUMN.1 will overlay what ever is already in that column.  (F and*/
/* XCOLUMN.1 P targets make room for the result to be inserted into). */
Queue 'COLCMD'
/* XCOLUMN.2 Whoops!*/
/* XCOLUMN.2 We just overlayed some data. */
/* XCOLUMN.2 Let's undo that operation.  */
Queue 'COLPRF UNDO'
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????dddddd?????ddddd?????????????????????????d*'
/* XCOLUMN.5 Delete columns.                                           */
/* XCOLUMN.5 D* indicates to delete to end of the line.                */
Queue 'COLCMD'
Queue 'COLCMD       ?????????????????????????????????????????????mmmmmmm????????f????????????'
/* XCOLUMN.7 Move columns Following another. */
Queue 'COLCMD'
/* XCOLUMN.8 Of course we could have used "C" to copy text   */
/* XCOLUMN.8 instead of move and a "P" to precede instead of */
/* XCOLUMN.8 following just as in XEDIT prefix commands.     */
Queue 'COLCMD       ??????????????????????????????????????????????lllllll????????????????????'
/* XCOLUMN.9 Convert columns to Lower case. */
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????????????????????kkkkkkk????????????????????'
/* XCOLUMN.11 Convert columns to Upper case. */
/* XCOLUMN.11 (King size that is.)           */
/* XCOLUMN.11 I suppose that "L" stood for Little Size! */
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????mmmmm?????????f????????????????????????????'
/* XCOLUMN.13 Move more columns Following another. */
Queue 'COLCMD'
Queue 'COLCMD       ????????????????????????????????????r-???????????????????????????????????'
/* XCOLUMN.15 Replace columns with some text.*/
/* XCOLUMN.15 In this case we are replacing a */
/* XCOLUMN.15 single character "-" */
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????????ix-???????????????????????????????'
/* XCOLUMN.17 Insert text into a column. */
/* XCOLUMN.17 Let us insert "x-"          */
Queue 'COLCMD'
/* XCOLUMN.18 Unlike replace, insert caused the */
/* XCOLUMN.18 text to slide over and make room  */
/* XCOLUMN.18 for the new text.                 */
Queue 'COLCMD       /i.* ????????????????????????????????????????????????????????????????????'
/* XCOLUMN.19 Now let us Insert text into column 1!  The "/" means to */
/* XCOLUMN.19 do the operation "here" and not behind the command as   */
/* XCOLUMN.19 would normally happen when using the insert command.    */
/* XCOLUMN.19 The "/" may be used with any command that has text      */
/* XCOLUMN.19 following it and is not limited to use in column 1.     */
Queue 'COLCMD'
Queue 'COLCMD       ddd??????????????????????????????????????????????????????????????????????'
/* XCOLUMN.21 Let us delete the Script comment .* text. */
Queue 'COLCMD'
/* XCOLUMN.22 We would like to insert an AT between the userid and*/
/* XCOLUMN.22 node, but not all lines contain userid and node.    */
Queue 'COLPCM x     ??????????????????????????????????????????????? ?????????????????????????'
/* XCOLUMN.23 Now for something new.  We are going    */
/* XCOLUMN.23 to use COL's Search and Do capability.  */
/* XCOLUMN.23 We are searching for a blank in column  */
/* XCOLUMN.23 48.  Whenever we find that condition we */
/* XCOLUMN.23 want to apply the XEDIT prefix command X*/
/* XCOLUMN.23 which will eXclude that line.           */
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????????????????????????????i AT???????????????'
/* XCOLUMN.25 Now we can insert the AT.  Lines */
/* XCOLUMN.25 which have been excluded will    */
/* XCOLUMN.25 not have the text inserted.      */
Queue 'COLCMD'
Queue 'COLPCM all   ?????????????????????????????????????????????????????????????????????????'
/* XCOLUMN.27 Let us show all lines by using XEDIT's ALL command.*/
/* XCOLUMN.27 Commands in the COL prefix area that are not used */
/* XCOLUMN.27 by COL are relayed onto XEDIT.  Remember that     */
/* XCOLUMN.27 some commands such as UNDO are used by COL itself.*/
Queue 'COLCMD'
Queue 'COLCMD       ?????????????????????????????""""5???????????????????????????????????????'
/* XCOLUMN.29 We can also replicate columns by using the " command */
/* XCOLUMN.29 just like we can in the XEDIT prefix area.           */
Queue 'COLCMD'
Queue 'COLPRF UNDO'
/* XCOLUMN.31 Let us undo that! */
Queue 'COLCMD'
Queue 'COLCMD       ?????????????????????a5??????????????????????????????????????????????????'
/* XCOLUMN.33 We can also add blank columns by using the A command.*/
/* XCOLUMN.33 Again this is the same as the XEDIT prefix command.  */
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????sss???????????????????????????????????'
/* XCOLUMN.35 Let us now sort the lines based on the */
/* XCOLUMN.35 information in columns 36 through 38.  */
Queue 'COLCMD'
/* XCOLUMN.36 Notice that this "Department Number" is the same for */
/* XCOLUMN.36 several individuals.  It might be easier to read if */
/* XCOLUMN.36 the department number appeared only once at the beginning */
/* XCOLUMN.36 of each group and then was blank until the next group. */
Queue 'COLCMD       ???????????????????????????????????___???????????????????????????????????'
/* XCOLUMN.37 We can "de-emulate" using the underscore as a command.*/
/* XCOLUMN.37 This operation will blank out repetitive text in a column.*/
Queue 'COLCMD'
/* XCOLUMN.38 De-emulate?  Well emulate means to copy something.    */
/* XCOLUMN.38 If we emulate a column, then blank columns will receive */
/* XCOLUMN.38 a copy of the text above it.                            */
Queue 'COLCMD       ???????????????????????????????????eee???????????????????????????????????'
/* XCOLUMN.39 Let us use the Emulate command */
/* XCOLUMN.39 to fill in the blanks.       */
Queue 'ECOL'
/* XCOLUMN.40 By the way, did you ever wonder what that _ was  */
/* XCOLUMN.40 in the help line behind the "Emul_".  I'll bet it*/
/* XCOLUMN.40 was to remind us what the de-emulate command is!   */
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLSRTD:
Queue 'COLPCM x     :dt?????????????????????????????????????????????????????????????????????'
/* XCOLSRTD.1 Search for :dt starting in column 1.*/
/* XCOLSRTD.1 When found apply the XEDIT prefix   */
/* XCOLSRTD.1 command X to eXclude the line.      */
Queue 'COLCMD'
Queue 'COLCMD       /a20????????????????????????????????????????????????????????????????????'
/* XCOLSRTD.3 Add 20 blank columns to the      */
/* XCOLSRTD.3 displayed lines starting in      */
/* XCOLSRTD.3 column 1.  Blanks are normally   */
/* XCOLSRTD.3 added after the A.  The / means  */
/* XCOLSRTD.3 do it here.                      */
Queue 'COLCMD'
Queue 'COLPCM all   ????????????????????????????????????????????????????????????????????????'
/* XCOLSRTD.5 Redisplay ALL lines.  */
Queue 'COLCMD'
Queue 'COLCMD       ????eeeeeeeeeeeeeeee????????????????????????????????????????????????????'
/* XCOLSRTD.7 Emulate or copy the text  */
/* XCOLSRTD.7 forward in columns 5 - 20.*/
Queue 'COLCMD'
Queue 'COLCMD       ????ssssssssssssssss????????????????????????????????????????????????????'
/* XCOLSRTD.9 Sort the text. */
Queue 'COLCMD'
Queue 'COLPCM x     :dt?????????????????????????????????????????????????????????????????????'
/* XCOLSRTD.11 Search for :dt starting in column 1.*/
/* XCOLSRTD.11 When found apply the XEDIT prefix   */
/* XCOLSRTD.11 command X to eXclude the line.      */
Queue 'COLCMD'
Queue 'COLCMD       d20?????????????????????????????????????????????????????????????????????'
/* XCOLSRTD.13 Delete the 20 columns we added*/
/* XCOLSRTD.13 on the displayed lines.*/
Queue 'COLCMD'
Queue 'COLXED ALL'
/* XCOLSRTD.15 Redisplay ALL lines.  */
Queue 'ECOL'
/* XCOLSRTD.16 PRESTO!*/
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLTWO:
Queue 'COLCMD       ???????????????????????????????????????????y*????????????????????????????????'
/* XCOLTWO.1 Mark the columns to be operated    */
/* XCOLTWO.1 upon.  The Y* indicates that the   */
/* XCOLTWO.1 column goes to the end of the line.*/
Queue 'COLPRF D /Gambon/'
/* XCOLTWO.2 Delete Gambon from the list but  */
/* XCOLTWO.2 leave the first columns as is.   */
Queue 'COLPRF I :3'
/* XCOLTWO.3 Try an Insert.*/
Queue 'COLPRF D :4'
/* XCOLTWO.4 Try an Delete again.*/
/* XCOLTWO.4 I can't believe this*/
/* XCOLTWO.4 is really working!  */
Queue 'COLPRF M :5'
/* XCOLTWO.5 Try an Move.*/
Queue 'COLPRF F :2'
/* XCOLTWO.6 Following this line.*/
Queue 'COLPRF RESET'
/* XCOLTWO.7 Remove the Y's from the command line.   */
/* XCOLTWO.7 (Is this just like XEDIT's RESET command*/
/* XCOLTWO.7 to remove pending prefix commands?)     */
Queue 'ECOL'
/* XCOLTWO.8 This is Great!*/
/* XCOLTWO.8 Why didn't I know how*/
/* XCOLTWO.8 to do this before?*/
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLTWOA:
Queue 'COLCMD       ???????????????????????????????????????????y*????????????????????????????????'
/* XCOLTWOA.1 Mark the columns to be operated    */
/* XCOLTWOA.1 upon.  The Y* indicates that the   */
/* XCOLTWOA.1 column goes to the end of the line.*/
Queue 'COLXED PUTD *'
/* XCOLTWOA.2 Issue the XEDIT command PUTD *.                    */
/* XCOLTWOA.2 */
/* XCOLTWOA.2 PUTD?  What is that?  Well it does a PUT and Delete*/
/* XCOLTWOA.2 to the End of the column (*).  It's in the Book.   */
/* XCOLTWOA.2 (XEDIT book that is.)*/
Queue 'COLPRF RESET'
/* XCOLTWOA.3 Remove the Y's from the command line.   */
Queue 'COLXED * GET'
/* XCOLTWOA.4 Issue the XEDIT command * GET.  */
/* XCOLTWOA.4 */
/* XCOLTWOA.4 Now what?  Go to the end of the */
/* XCOLTWOA.4 column and GET what we just PUT!*/
Queue 'COLCMD'
/* XCOLTWOA.5 Humm...*/
Queue 'COLCMD       s2ss s1sssssssssssss?????????????????????????????????????????????????????????'
/* XCOLTWOA.6 Let us sort by last name*/
/* XCOLTWOA.6 and then first initials.*/
Queue 'COLCMD'
/* XCOLTWOA.7 Let us put this new list*/
/* XCOLTWOA.7 back into two columns.*/
Queue 'COLXED :8 PUTD *'
/* XCOLTWOA.8 Let me guess!  Go to line 8*/
/* XCOLTWOA.8 and PUT and Delete everything*/
/* XCOLTWOA.8 to the end of the column.    */
Queue 'COLCMD'
/* XCOLTWOA.9 Right!*/
Queue 'COLCMD       ???????????????????????????????????????????y*????????????????????????????????'
/* XCOLTWOA.10 Mark the columns to place the text into.*/
Queue 'COLXED GET'
/* XCOLTWOA.11 Now GET what we just PUT!*/
Queue 'ECOL'
/* XCOLTWOA.12 I think I'll try this again..*/
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLTALI:
Queue 'COLCMD       ?????????????q,??????????????????????????????????????????????????????????'
/* XCOLTALI.1 Queue or align the text requested.  In*/
/* XCOLTALI.1 this case search for a ",".  If found */
/* XCOLTALI.1 queue the requested text at the Q.    */
Queue 'COLCMD'
Queue 'COLPRF UNDO'
/* XCOLTALI.3 Well that worked great!  All of my  */
/* XCOLTALI.3 aligned text is now all jumbled up! */
/* XCOLTALI.3 AND my lines have been truncated!   */
/* XCOLTALI.3 Undo that operation...              */
Queue 'COLCMD'
Queue 'COLCMD       z????????????q,????????????????????z?????????????????????????????????????'
/* XCOLTALI.5 Let us limit our queue request to */
/* XCOLTALI.5 occur between zones from now on.*/
Queue 'COLCMD'
/* XCOLTALI.6 That's better.*/
Queue 'COLCMD       z??????????????????q)??????????????z?????????????????????????????????????'
/* XCOLTALI.7 Queue the )'s.*/
Queue 'COLCMD'
Queue 'COLCMD       ?????????????ddd???dddddddddddd??????????????????????????????????????????'
/* XCOLTALI.9 Delete unwanted columns.*/
Queue 'COLCMD'
Queue 'COLCMD       ?????????????i.??????????????????????????????????????????????????????????'
/* XCOLTALI.11 Insert a period behind the first initial.*/
Queue 'COLCMD'
/* XCOLTALI.12 Now we would like to insert a period*/
/* XCOLTALI.12 behind the second initial.  However,*/
/* XCOLTALI.12 many do not have a second initial.  */
Queue 'COLPCM x     ??????????????? ?????????????????????????????????????????????????????????'
/* XCOLTALI.13 Search for a blank in column 16. */
/* XCOLTALI.13 When found issue the XEDIT prefix*/
/* XCOLTALI.13 command X to eXclude the line.   */
Queue 'COLCMD'
Queue 'COLCMD       ???????????????i.????????????????????????????????????????????????????????'
/* XCOLTALI.15 Insert a period behind the second initial.*/
/* XCOLTALI.15 of those who are being displayed.         */
Queue 'COLCMD'
Queue 'COLPCM all   ?????????????????????????????????????????????????????????????????????????'
/* XCOLTALI.17 Display ALL lines.*/
Queue 'COLCMD'
/* XCOLTALI.18 Whoops! The insert caused the displayed text to move over*/
/* XCOLTALI.18 and now we are no longer aligned.  Maybe we should have */
/* XCOLTALI.18 used the Replace command rather than the Insert command.*/
Queue 'COLCMD       ??????????????????????jl?????????????????????????????????????????????????'
/* XCOLTALI.19 Oh Well, let's just   */
/* XCOLTALI.19 left Justify the text.*/
Queue 'COLCMD'
Queue 'COLCMD       p????????????mmmmm???????????????????????????????????????????????????????'
/* XCOLTALI.21 Move the initials (and one blank)*/
/* XCOLTALI.21 previous to the first column.    */
Queue 'COLCMD'
Queue 'COLCMD       ????????????????????jr???????????????????????????????????????????????????'
/* XCOLTALI.23 Let us right justify the names   */
/* XCOLTALI.23 to see what that looks like.     */
Queue 'COLCMD'
Queue 'COLCMD       jl???????????????????????????????????????????????????????????????????????'
/* XCOLTALI.25 That's nice, let us left*/
/* XCOLTALI.25 justify the names.    */
Queue 'COLCMD'
/* XCOLTALI.26 NO NO NO.... Undo that one!*/
Queue 'COLPRF UNDO'
Queue 'COLCMD'
Queue 'COLCMD       jl??????????????????j????????????????????????????????????????????????????'
/* XCOLTALI.29 Left justify between the J's.*/
Queue 'COLCMD'
Queue 'COLCMD       jc???????????????????j???????????????????????????????????????????????????'
/* XCOLTALI.31 Maybe it would look better if*/
/* XCOLTALI.31 the names were centered.     */
Queue 'ECOL'
/* XCOLTALI.32 Time to Quit!*/
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLEXAM:
Queue 'COLPCM x     .im??????????????????????????????????????????????????????????????????????'
/* XCOLEXAM.1 We need to sort these lines by the persons last name.   */
/* XCOLEXAM.1 But we need to leave the .im lines alone.  We can search*/
/* XCOLEXAM.1 for a .im starting in column 1 and when found issue the */
/* XCOLEXAM.1 XEDIT prefix command X to eXclude those lines.          */
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????????q?????????????????????????????????'
/* XCOLEXAM.3 Now Q. (Star Trek the Next Generation?)  Since no text  */
/* XCOLEXAM.3 has been entered after the command, the Q command will  */
/* XCOLEXAM.3 queue or align the last blank delimited word.           */
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????????ssssssssssssss????????????????????'
/* XCOLEXAM.5 Sort the text based on the last name.*/
Queue 'COLCMD'
Queue 'COLCMD       ?????????????????????????????????????b???????????????????????????????????'
/* XCOLEXAM.7 Remove trailing blanks up to the B.*/
Queue 'COLCMD'
Queue 'COLXED ALL'
/* XCOLEXAM.9 Redisplay ALL lines.*/
Queue 'ECOL'
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLTRAN:
Queue 'COLPCM TRANS ????????????????????????????????????????????????????????????????????????'
/* XCOLTRAN.1 We would like to sort the columns based on the userid    */
/* XCOLTRAN.1 in the fourth line.  That is the column with BOLES       */
/* XCOLTRAN.1 should come first followed by the columns with CATANIA   */
/* XCOLTRAN.1 and so forth.  If only we could make rows become         */
/* XCOLTRAN.1 columns, then we could use the normal SORT routines.     */
/* XCOLTRAN.1 Use the TRANSpose prefix command to do just that.        */
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????sssssssss?????????????????????????????????????????????????????????????????????????????????????????????????????????'
/* XCOLTRAN.3 Now sort based on the third column.*/
Queue 'COLCMD'
/* XCOLTRAN.4 Great!  But now to put everything back.*/
Queue 'COLPCM TRANS ????????????????????????????????????????????????????????????????????????'
/* XCOLTRAN.5 TRANS again.  Note that the  */
/* XCOLTRAN.5 semicolons in the first line */
/* XCOLTRAN.5 mark the column locations.   */
Queue 'ECOL'
/* XCOLTRAN.6 I didn't know we could do that!*/
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLATAB:
'COMMAND SET CURLINE ON M'
Queue 'COLPCM atab^ ??????????????????????????????????????????????????????????????????????????????????????'
/* XCOLATAB.1 This uses the autotab COL prefix command atab.  Right  */
/* XCOLATAB.1 behind the command we enter the character that defines */
/* XCOLATAB.1 our tab character.  In this case it is the ^ character.*/
/* XCOLATAB.1 It can be any character including a blank!             */
Queue 'COLCMD'
/* XCOLATAB.2 You get two spaces */
/* XCOLATAB.2 between each column.*/
Queue 'COLCMD       r^    ^     ^         ^       ^???????????????????????????????????????????????????????'
/* XCOLATAB.3 Maybe you want to add the tab character back   */
/* XCOLATAB.3 into the text.  We can try the Replace command.*/
Queue 'COLCMD'
/* XCOLATAB.4 Whoops!  The blanks also replaced the data?  */
Queue 'COLPRF UNDO'
/* XCOLATAB.5 Undo that one.*/
Queue 'COLCMD'
/* XCOLATAB.6 Maybe I'll have to do each column one at R^ */
/* XCOLATAB.6 a time?  (Or maybe there is another command)*/
Queue 'COLCMD       o^    ^     ^         ^       ^???????????????????????????????????????????????????????'
/* XCOLATAB.7 Oh yes, the Overlay command.  It works just*/
/* XCOLATAB.7 like XEDIT's COVERLAY command.  Blanks are */
/* XCOLATAB.7 not replaced.  I have to use an underscore */
/* XCOLATAB.7 to replace blanks.  (But then I can't      */
/* XCOLATAB.7 replace text with an underscore!)          */
Queue 'ECOL'
/* XCOLATAB.8 Well that was faster than*/
/* XCOLATAB.8 a lot of R^ commands!*/
'LOCATE :4 MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLBLAN:
Queue 'COLPCM D     @@@@@@@@@@@@@@@@@@@@@@@@@????????????????????????????????????????????????'
/* XCOLBLAN.1 Search for blanks in column 1 - 25. */
/* XCOLBLAN.1 When found apply the XEDIT prefix   */
/* XCOLBLAN.1 command D to Delete the line.       */
Queue 'COLCMD'
Queue 'COLPCM I     @????????????????????????????????????????????????????????????????????????'
/* XCOLBLAN.3 Search for a blank in column 1.     */
/* XCOLBLAN.3 When found apply the XEDIT prefix   */
/* XCOLBLAN.3 command I to Insert a line.         */
Queue 'COLCMD'
Queue 'COLPRF UNDO'
/* XCOLBLAN.5 Let us undo that operation and insert */
/* XCOLBLAN.5 something other than a blank line.  */
/* XCOLBLAN.5 We will insert a Script .br command.*/
Queue 'COLXCM       @{I .br}'
/* XCOLBLAN.6 Search for blanks in column 1.      */
/* XCOLBLAN.6 When found apply the XEDIT command  */
/* XCOLBLAN.6 I .br to insert the desired text.   */
Queue 'ECOL'
'MACRO COL * ? @ NOEXIT NOPROF STEP'
Return
 
XCOLNUMB:
'COMMAND LOCATE * ADD 14'
'COMMAND TOP'
Queue 'COLCMD       nn???????????????????????????????????????????????????????????????????????'
/* XCOLNUMB.1 Let us now have some fun with numbers.  We*/
/* XCOLNUMB.1 will place sequence numbers in the first*/
/* XCOLNUMB.1 two columns using the Number command.   */
Queue 'COLCMD'
/* XCOLNUMB.2 What if we wanted     */
/* XCOLNUMB.2 them left justified?  */
Queue 'COLCMD       jjl??????????????????????????????????????????????????????????????????????'
/* XCOLNUMB.3 Use the Justify Left command.  We */
/* XCOLNUMB.3 are just working between the J's. */
Queue 'COLCMD'
Queue 'COLCMD       ??nnn????????????????????????????????????????????????????????????????????'
/* XCOLNUMB.5 Lets get more numbers.  But this time I */
/* XCOLNUMB.5 want to start with 9 and a couple of    */
/* XCOLNUMB.5 lines later I want to start over with 5.*/
Queue 'COLCMD'
/* XCOLNUMB.6 I want leading zeros!*/
Queue "COLCMD       ??'0?????????????????????????????????????????????????????????????????????"
/* XCOLNUMB.7 Use the Pad ' command*/
/* XCOLNUMB.7 to overlay text into */
/* XCOLNUMB.7 blank columns.       */
Queue 'COLCMD'
Queue 'COLCMD       ????????n????????????????????????????????????????????????????????????????'
/* XCOLNUMB.9 What if I only*/
/* XCOLNUMB.9 enter one N?  */
Queue 'COLCMD'
/* XCOLNUMB.10 You only get one column of numbers!*/
Queue 'COLCMD       ????????????nnn(.1???????????????????????????????????????????????????????'
/* XCOLNUMB.11 Lets get numbers incremented*/
/* XCOLNUMB.11 by .1 starting with 0.0!    */
Queue 'COLCMD'
Queue 'COLCMD       ????????????????????n(a??????????????????????????????????????????????????'
/* XCOLNUMB.13 Alpha?*/
Queue 'COLCMD'
/* XCOLNUMB.14 Right!*/
/* XCOLNUMB.14 */
/* XCOLNUMB.14 But suppose you wanted uppercase?*/
/* XCOLNUMB.14 You get uppercase if XEDIT's CASE*/
/* XCOLNUMB.14 is set to Upper.                 */
Queue 'COLCMD       ?????????????????????????n(A?????????????????????????????????????????????'
/* XCOLNUMB.15 But if you use "A" instead of "a" as the option you    */
/* XCOLNUMB.15 will get uppercase.  Of course you could have converted*/
/* XCOLNUMB.15 the column to uppercase by using the K command.        */
/* XCOLNUMB.15                                                        */
Queue 'COLCMD'
Queue 'COLCMD       ?????????????????????????????nnn(A???????????????????????????????????????'
/* XCOLNUMB.17 Let us start with a specific letter */
/* XCOLNUMB.17 and see what happens when we pass Z.*/
Queue 'COLCMD'
Queue 'COLCMD       ????????????????????????????????????n(A-1????????????????????????????????'
/* XCOLNUMB.19 Can we increment by -1?*/
Queue 'COLCMD'
/* XCOLNUMB.20 Good!*/
Queue 'COLCMD       ???????????????????????????????????????????n(A2??????????????????????????'
/* XCOLNUMB.21 Can we increment by 2?*/
Queue 'COLCMD'
/* XCOLNUMB.22 OK!!!*/
Queue 'COLCMD       ????????????????????????????????????????????????nnn(x????????????????????'
/* XCOLNUMB.23 Hex?*/
Queue 'COLCMD'
/* XCOLNUMB.24 I may be able to use this after all!*/
/* XCOLNUMB.24 If only I had binary...             */
Queue 'COLCMD       ???????????????????????????????????????????????????????nnnn(b????????????'
/* XCOLNUMB.25 Maybe...*/
Queue 'COLCMD'
/* XCOLNUMB.26 Yea!*/
/* XCOLNUMB.26 I see that this one started with 0.*/
Queue 'COLCMD       ???????????????????????????????????????????????????????????????n(1,3?????'
/* XCOLNUMB.27 You can also count by an increment such */
/* XCOLNUMB.27 as 1 starting over when you reach 3.    */
Queue 'COLCMD'
Queue 'COLCMD       ?????????????????????????????????????????????????????????????????????nn\?'
/* XCOLNUMB.29 If you use the backward operator \ */
/* XCOLNUMB.29 you will number UP the column.     */
Queue 'ECOL'
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLCOUN:
Queue 'COLCMD ssssssss     '
/* XCOLCOUN.1 Our goal for this session is to determine how many */
/* XCOLCOUN.1 numbers there are in this list that are identical. */
/* XCOLCOUN.1 In other words how many 12345678's are there?      */
/* XCOLCOUN.1 Let us first sort to get the numbers in groups.    */
Queue 'COLCMD'
Queue 'COLCMD ????????r   1'
/* XCOLCOUN.3 Now place a series of "1"s into a column */
/* XCOLCOUN.3 that we will use for counting purposes.  */
Queue 'COLCMD'
Queue 'COLCMD _____________'
/* XCOLCOUN.5 De-emulate or blank all information using*/
/* XCOLCOUN.5 the _ command.  This includes the number */
/* XCOLCOUN.5 and the "1"s that we just entered.       */
Queue 'COLCMD'
/* XCOLCOUN.6 OK, but what did that gain?*/
Queue 'COLCMD eeeeeeee nnnn'
/* XCOLCOUN.7 Let us put the numbers back in and use*/
/* XCOLCOUN.7 the Number command to count for us.   */
/* XCOLCOUN.7 Every time a "1" is encountered the    */
/* XCOLCOUN.7 number sequence will start over at 1.  */
Queue 'COLCMD'
/* XCOLCOUN.8 OK, I see the number I want, let */
/* XCOLCOUN.8 us get rid of the unwanted lines.*/
Queue 'COLCMD ________\'
/* XCOLCOUN.9 De-emulate or blank the number   */
/* XCOLCOUN.9 column from the bottom up.       */
Queue 'COLCMD'
Queue 'COLPCM D @@@@@@@@'
/* XCOLCOUN.11 We can now delete all lines that */
/* XCOLCOUN.11 have blanks in the first 8 columns.*/
Queue 'ECOL'
/* XCOLCOUN.12 We now have our report*/
'MACRO COL * ? @ NOEXIT STEP'
Return
 
XCOLDEL:
Queue 'COLCMD ssssssss     '
/* XCOLDEL.1 Group the data*/
/* XCOLDEL.1 by sorting.   */
Queue 'COLCMD'
Queue 'COLCMD ________'
/* XCOLDEL.3 Now let us blank the duplicate information*/
/* XCOLDEL.3 by using the _ command to de-emulate.     */
Queue 'COLCMD'
Queue 'COLPCM D @@@@@@@@'
/* XCOLDEL.5 Now we search for blanks in our column */
/* XCOLDEL.5 and when found we delete that line.    */
Queue 'ECOL'
/* XCOLDEL.6 That was fast!*/
'MACRO COL * ? @ NOEXIT STEP'
Return
 
XCOLMARK:
Queue 'COLCMD ???????????????????????????????????????nnnn'
/* XCOLMARK.1 Place sequence numbers*/
/* XCOLMARK.1 in an unused column.  */
Queue 'COLCMD'
/* XCOLMARK.2 Good Idea!  We might need it later to restore*/
/* XCOLMARK.2 the line order to this original sequence.    */
Queue 'COLCMD ssssssss     '
/* XCOLMARK.3 Now sort the data.*/
Queue 'COLCMD'
/* XCOLMARK.4 Oh Yes, I see a */
/* XCOLMARK.4 duplicate now.*/
Queue 'COLCMD ________'
/* XCOLMARK.5 Blank out the duplicate data.*/
Queue 'COLCMD'
/* XCOLMARK.6 There were more than I thought!*/
Queue 'COLPCM X^ @@@@@@@@'
/* XCOLMARK.7 eXclude all lines that*/
/* XCOLMARK.7 do NOT have blanks.*/
Queue 'COLCMD'
Queue 'COLPCM S@-1 @@@@@@@@'
/* XCOLMARK.9 Show each line above*/
/* XCOLMARK.9 (@-1) the blanks.   */
Queue 'COLCMD'
/* XCOLMARK.10 Now to restore*/
/* XCOLMARK.10 the data.     */
Queue 'COLCMD eeeeeeee'
/* XCOLMARK.11 Emulate!*/
Queue 'COLCMD'
Queue 'COLCMD ???????r*'
/* XCOLMARK.13 Let us place a marker on*/
/* XCOLMARK.13 each duplicate entry.*/
Queue 'COLCMD'
Queue 'COLPRF ALL'
/* XCOLMARK.15 Show ALL lines.*/
Queue 'COLCMD'
/* XCOLMARK.16 Now to restore the data back */
/* XCOLMARK.16 to it's original sequence.   */
Queue 'COLCMD ???????????????????????????????????????ssss'
/* XCOLMARK.17 Sure am glad we put in those  */
/* XCOLMARK.17 sequence numbers at the start!*/
/* XCOLMARK.17 Now we only have to sort.     */
Queue 'COLCMD'
Queue 'COLCMD ??????????????????????????????????????r@@@@'
/* XCOLMARK.19 Blank out that column.*/
/* XCOLMARK.19 We don't need it any more.*/
Queue 'ECOL'
'MACRO COL * ? @ NOEXIT STEP'
Return
 
XCOLCOMP:
Queue 'COLMAT       yyyyyyyy?????????????????????????????yyyyyyyy??={y.1 = y.2}'
/* XCOLCOMP.1 Mark the columns to be compared with Y's and place an  */
/* XCOLCOMP.1 equal sign where the REXX True/False (1/0) answer is to*/
/* XCOLCOMP.1 be placed.  Simultaneously enter a REXX expression into*/
/* XCOLCOMP.1 the XEDIT command line.  y.1 = y.2 is a request to test*/
/* XCOLCOMP.1 if the first column equals the second column.          */
Queue 'COLCMD'
/* XCOLCOMP.2 OK!*/
Queue 'COLPCM X     ???????????????????????????????????????????????1'
/* XCOLCOMP.3 Now lets eXclude each line*/
/* XCOLCOMP.3 with a 1 in column 48.    */
Queue 'COLCMD'
Queue 'COLCMD       ???????r*'
/* XCOLCOMP.5 Let us place an *   */
/* XCOLCOMP.5 to mark these lines.*/
Queue 'COLCMD'
Queue 'COLXED ALL'
/* XCOLCOMP.7 Show All lines.*/
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????????????????????r@'
/* XCOLCOMP.9 Blank the 1/0*/
/* XCOLCOMP.9 column.      */
Queue 'ECOL'
'MACRO COL * ? @ NOEXIT STEP'
Return
 
XCOLADD:
Queue 'COLCMD       ????????????????????????+++++++++++'
/* XCOLADD.1 To add a column of numbers place + over the columns to be */
/* XCOLADD.1 added.  The sum is placed at the end of the column right  */
/* XCOLADD.1 aligned with the right most +.  If the numbers contain    */
/* XCOLADD.1 commas or dollar signs, then the answer also will contain */
/* XCOLADD.1 the same.  Columns that do not contain numbers such as the*/
/* XCOLADD.1 ========= are ignored.                                    */
Queue 'COLCMD'
/* XCOLADD.2 Make sure that your column of +'s cover your largest      */
/* XCOLADD.2 number.  You might want to use the COL prefix command     */
/* XCOLADD.2 PIC to show a picture of where the blanks and non blanks  */
/* XCOLADD.2 are in your data before doing the + command.              */
Queue 'COLPRF PIC'
Queue 'COLCMD       @?????@????@@@@@@@@@@@@@@@@????????@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
/* XCOLADD.4 There are ? above columns that have text and              */
/* XCOLADD.4 blanks above the columns that are blank.                  */
Queue 'COLXED :10 DELETE 2'
/* XCOLADD.5 Let us remove the bottom 2 lines  and */
/* XCOLADD.5 explore other COL + command options */
Queue 'COLCMD       ????????????????????????++++++++++++++++++++++++(c'
/* XCOLADD.6 We can do Cumulative totals using */
/* XCOLADD.6 the C option behind the + command.*/
Queue 'COLCMD'
/* XCOLADD.7 Again the total is right justified*/
/* XCOLADD.7 with the rightmost +.             */
Queue 'COLPRF UNDO'
Queue 'COLCMD       ????????????????????????"""""""""""'
/* XCOLADD.9 We will now get a second column   */
/* XCOLADD.9 (identical in this case).         */
Queue 'COLCMD'
Queue 'COLCMD       ????????????????????????++++++++++++++++++++++++++++++++++(L'
/* XCOLADD.11 We can do Line totals using */
/* XCOLADD.11 the L option behind the + command.*/
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????????????d*'
Queue 'COLXED * ADD 1'
/* XCOLADD.14 Now to see the Subtotal option.   */
/* XCOLADD.14 Let us do a couple of XEDIT commands*/
/* XCOLADD.14 to get a second set of data.      */
Queue 'COLXED :4 COPY * *'
Queue 'COLCMD       ????????????????????????+++++++++++++++++++++++(S'
/* XCOLADD.16 The S option will create */
/* XCOLADD.16 subtotals for us.        */
Queue 'ECOL'
'MACRO COL * ? @ NOEXIT NOPROF STEP'
Return
 
XCOLREMO:
/* alignment tool!  ....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....8 */
Queue 'COLCMD       ????????????????????????????-$$$$$$$$'
/* XCOLREMO.1 Let us remove all $ signs*/
/* XCOLREMO.1 within a specific column.*/
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????????????-000'
/* XCOLREMO.3 Let us remove all*/
/* XCOLREMO.3 those leading 0's*/
Queue 'COLCMD'
/* XCOLREMO.4 Whoops!*/
/* XCOLREMO.4 All the zeros went away. */
/* XCOLREMO.4 I only wanted the leading*/
/* XCOLREMO.4 zeros to be removed!     */
Queue 'COLPRF UNDO'
/* XCOLREMO.5 Undo that one.*/
Queue 'COLCMD       ??????????????????????????????????????????- 000'
/* XCOLREMO.6 If the command is a "minus blank", then the  */
/* XCOLREMO.6 removal process is a left to right operation,*/
/* XCOLREMO.6 stopping whenever a non-match is found.      */
Queue 'ECOL'
/* XCOLREMO.7 That's better!*/
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLTITL:
'COMMAND SET CASE M R'
'COMMAND VARBLANK OFF'
Queue 'COLCMD       sssssssssssssssssssssssssssssssssss'
/* XCOLTITL.1 Let us sort this*/
/* XCOLTITL.1 list of titles. */
Queue 'COLCMD'
/* XCOLTITL.2 Humm...*/
/* XCOLTITL.2 This does not look right!  I think that titles are supposed to  */
/* XCOLTITL.2 be sorted as though there were no blanks, apostrophes or leading*/
/* XCOLTITL.2 "The's".  For example, "Imitation Of Life" should come before   */
/* XCOLTITL.2 both "I Remember Moma" and "I'm No Angel".  "The Informer"      */
/* XCOLTITL.2 should not have disappeared to the bottom of the list.          */
Queue 'COLPRF UNDO'
/* XCOLTITL.3 Undo that!*/
Queue 'COLCMD       """""""""""""""""""""""""""""""""""""""'
/* XCOLTITL.4 Let us make a duplicate*/
/* XCOLTITL.4 column of the data.    */
Queue 'COLCMD'
Queue "COLCMD       ???????????????????????????????????????-'''''''''''''''''''''''''''''''''''''''"
/* XCOLTITL.6 Let us remove all apostrophes.*/
Queue 'COLCMD'
Queue "COLCMD       ?????????????????????????????????????- The"
/* XCOLTITL.8 Remove "  The".  The leading blank indicates*/
/* XCOLTITL.8 that this operation is to proceed from left */
/* XCOLTITL.8 to right, rather than character by character*/
/* XCOLTITL.8 as was the case when we entered -,,,,,,,,,,.*/
Queue 'COLCMD'
/* XCOLTITL.9 On second thought, that might not have been a good idea!*/
/* XCOLTITL.9 We might have removed some text such as the first 3     */
/* XCOLTITL.9 letters of "Then" from the front of some titles.        */
Queue 'COLPRF UNDO'
/* XCOLTITL.10 Undo that one.*/
Queue 'COLPCM X^    ???????????????????????????????????????The ?'
/* XCOLTITL.11 Rather let us exclude all lines*/
/* XCOLTITL.11 that do not contain "The ".    */
Queue 'COLCMD       ???????????????????????????????????????dddd?'
/* XCOLTITL.12 Delete this occurrence.*/
Queue 'COLXED ALL'
/* XCOLTITL.13 Show ALL lines.*/
Queue 'COLCMD       ???????????????????????????????????????JL0????????? '
/* XCOLTITL.14 Let us left justify this data with*/
/* XCOLTITL.14 0 spaces between each word.       */
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????????k*'
/* XCOLTITL.16 King size the words (Upper case that is) so that*/
/* XCOLTITL.16 we do not need to worry about case sensitivity.  */
Queue 'COLCMD'
Queue 'COLCMD       ???????????????????????????????????????ssssssssssssssssssssssssssssssssss'
/* XCOLTITL.18 Sort again based*/
/* XCOLTITL.18 on this column. */
Queue 'COLCMD'
/* XCOLTITL.19 That looks better!*/
Queue 'COLCMD       ???????????????????????????????????????d*'
/* XCOLTITL.20 Now delete the column.*/
/* XCOLTITL.20 It has served it's purpose.*/
Queue 'COLCMD'
/* XCOLTITL.21 I think this is*/
/* XCOLTITL.21 correct now.*/
Queue 'COLCMD       ????????????????????????????????????q('
/* XCOLTITL.22 After all that hard work, let us   */
/* XCOLTITL.22 now sort instead by the year.  We  */
/* XCOLTITL.22 need to Queue or align the year.   */
Queue 'COLCMD'
Queue 'COLCMD       ?????????????????????????????????????ssss'
/* XCOLTITL.24 Sort!*/
Queue 'COLCMD'
Queue 'COLCMD       ??????????????????????????????????b'
/* XCOLTITL.26 Now lets remove those trailing*/
/* XCOLTITL.26 blanks that are between the   */
/* XCOLTITL.26 title and the year.           */
Queue 'ECOL'
/* XCOLTITL.27 I guess that is enough!*/
'MACRO COL * NOEXIT NOPROF STEP'
Return
 
XCOLREXX:
Queue 'COLMAT       yyyy?yyyy?====={y.1 + y.2}'
/* XCOLREXX.1 Add the first column to the second. */
/* XCOLREXX.1 The first  set of Y's is named y.1. */
/* XCOLREXX.1 The second set of Y's is named y.2. */
/* XCOLREXX.1 And so forth..... The "====="s      */
/* XCOLREXX.1 indicate where to place the answer. */
/* XCOLREXX.1 */
/* XCOLREXX.1 This entire screen must be set up   */
/* XCOLREXX.1 Prior to pressing ENTER!            */
Queue 'COLCMD'
Queue 'COLMAT       yyyy?yyyy??????????={y.1 > y.2}'
/* XCOLREXX.3 Is the first column larger*/
/* XCOLREXX.3 than the second?          */
Queue 'COLCMD'
Queue 'COLMAT       yyyy?yyyy????????????======.==={y.2 / y.1 * 100}'
/* XCOLREXX.5 Divide the second column by */
/* XCOLREXX.5 the first and multiply by 100.*/
/* XCOLREXX.5 The decimal point indicates   */
/* XCOLREXX.5 the placement within the answer.*/
Queue 'COLCMD'
/* XCOLREXX.6 You may build any mathematical or REXX*/
/* XCOLREXX.6 expression in the XEDIT command line! */
Queue 'COLXCM       ??????????????????????????????????===={MATH Random()}'
/* NOTE for any macro writers who may be reading this file  */
/* the above COLXCM command is used instead of the correct  */
/* COLMAT since I desire to show the user the requirement   */
/* that they enter MATH in this condition.  For macro usage */
/* it would not be necessary to enter MATH when using COLMAT*/
/* XCOLREXX.7 Obtain some random numbers.  In this case no Y's have  */
/* XCOLREXX.7 been specified on the COL command line or within the   */
/* XCOLREXX.7 REXX expression, so we must enter the optional "MATH". */
Queue 'COLCMD'
Queue 'COLPCM  d>   ?????????????????????????????????? 500'
/* XCOLREXX.9 Delete all lines greater than 500.  The leading*/
/* XCOLREXX.9 blank in front of the 500 is used to inform COL*/
/* XCOLREXX.9 as to the width of the column being searched.  */
/* XCOLREXX.9 In this case the width is 4 columns.           */
Queue 'COLCMD'
Queue 'COLXCM       ?????????????????????????????????====={y.0 + 12}'
/* XCOLREXX.11 Now let us add 12 to the column marked*/
/* XCOLREXX.11 with "====="'s The name of this column*/
/* XCOLREXX.11 is y.0.  This is an update in place.  */
Queue 'COLCMD'
Queue 'COLXCM       ?????????????????????????????????yyyyy???=====.=={y.1 * 0.25 + y.00}'
/* XCOLREXX.13 Lastly let us use the y.00 variable which is*/
/* XCOLREXX.13 the name of the last result.  In this case  */
/* XCOLREXX.13 we are adding 25 percent of the y.1 column  */
/* XCOLREXX.13 to the previous result or a running total.  */
Queue 'ECOL'
'MACRO COL * NOEXIT NOPROF STEP'
Return
